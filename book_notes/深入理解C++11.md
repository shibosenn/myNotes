#

## C++11新特性

### __func__预定义标识符

基本功能：返回所在函数的名字
>notes：初始化成员列表使用__func__是可行的，但是作为函数参数的默认值是不允许的

### __VA_ARGS__

```c++
#define PR(...) printf(__VA_ARGS__)
````

### 静态断言

`static_assert` 在编译时进行检查，接收两个参数

下面是一个使用 ```static_assert``` 的简单示例：

```c++
static_assert(sizeof(int) == 4, "int must be 4 bytes");
```

#### 使用范例

* 检查类型特征：可以使用 ```is_same```、```is_base_of``` 等类型特征来检查类型关系，并用静态断言来进行分类讨论或错误报告。

    ```c++
    #include <type_traits>
    
    static_assert(std::is_same<int, int>::value, "int is not int");
    static_assert(std::is_same<float, double>::value, "float is not double");
    ```

* 检查编译时常量：可以使用 ```constexpr``` 关键字来定义编译时常量，使用 ```static_assert``` 来检查常量的值是否符合预期。

### noexcept

noexcept 用于指定函数是否可能抛出异常。它可以出现在函数声明或定义的末尾，并有两种形式：

* ```noexcept```：表示该函数不会抛出任何异常。
* ```noexcept(expression)```：expression 是一个可以在编译时计算出结果的表达式，如果它的结果为 true，则表示该函数不会抛出异常，否则表示该函数可能会抛出异常。

#### 优点

使用 ```noexcept``` 可以帮助编译器进行优化，从而提高程序的性能。例如，当调用一个标记为 ```noexcept``` 的函数，编译器可以不生成异常处理代码，从而减少程序的开销。另外，在 STL 中，如果一个容器的元素类型提供了 noexcept 标记的移动构造函数和移动赋值运算符，容器在进行元素移动时可以使用更快的方式，从而提高程序效率。

#### 注意

如果一个 ```noexcept``` 函数确实抛出异常，它会调用 ```std::terminate()```，从而终止程序运行。

### friend拓展应用

```c++
class P
template<typename T> class People 
{
    friend T;
}

People<P> a;     // 类型p被声明为People的友元
People<int> b;   // 对于int型， 友元声明被忽略
```

### final / override

```final```关键字用于防止子类重写

```override``` 显式指定子类重写父类

### 模版函数的默认模版参数

```c++
template<class T, class U = double>
void f(T t = 0, U u = 0);

int main() {
    f(1, "c");    
    f(1);
    f();           //错误， T无法被推倒出来
    f<int>()
}
//必须从右到左指定默认模版参数
```

### 继承构造函数

#### 编译器对于继承的理解

  1. 内存布局：在编译阶段，编译器会根据类的定义，确定类的内存布局。对于继承，编译器会为子类分配内存，其中包括父类成员的内存空间和子类自有成员的内存空间。在内存中，子类包含了一个父类的子对象。
  2. 访问控制：在访问成员时，编译器需要根据访问权限规则来确定是否可以访问某个成员。在 C++ 中，访问权限有三种：公有、保护、私有。子类可以访问父类的公有和受保护成员，但不能直接访问父类的私有成员。
  3. 调用父类构造函数：在子类构造函数中，需要调用父类的构造函数来初始化继承的成员。编译器需要保证构造函数的调用顺序，先调用父类的构造函数，再调用子类的构造函数。
  4. 虚函数：在子类中重载父类的虚函数时，编译器需要生成虚函数表，并根据函数调用的动态类型来确定调用哪个实现

```c++
struct A {
    A(int i) {}
    A(double d, int i) {}
    A(float f, int i, const char* c) {}
};

struct B : A {
    using A :: A;
    virtual void ExtraInterface() {}
};
```

### 委派构造函数

```c++
class Info {
public:
    Info() : Info(1, 'a') {}
    Info(int i) : Info(i, 'a') {}
    Info(char e) : Info(1, e) {}
private:
    Info(int i, char e) : type(i), name(e){}
    int type;
    char name;
};
```

### 右值引用：移动语义和完美转发

#### 右值的概念

在c++11中，右值由两部分构成，一个将亡值，一个是纯右值（临时变量值，运算表达式，lambda表达式）

### explicit关键字

在 C++ 中，如果一个构造函数声明为 explicit，那么该构造函数只能被用于显式调用，而不能被隐式调用。

### 列表初始化与防止类型收窄

普通数组与结构体的```聚合初始化```：

* 普通的数组也可以通过列表初始化。这是因为 C++11 标准引入了一个新特性，即允许使用花括号 {} 对数组进行初始化。通过花括号 {} 进行初始化被称为“聚合初始化”。
* 当使用聚合初始化时，编译器会将花括号中的元素解析成一个数组，并将该数组用于初始化数组变量。在数组初始化时，编译器会自动计算出数组的大小，并根据初始化`表中的元素数目，自动分配足够的空间来存储数组元素。

需要注意的是，聚合初始化只能用于普通数组和结构体等```聚合类型```，不能用于类类型的对象初始化。

聚合类型的定义包括：

* 所有非静态成员都是 public 的非函数成员。
* 没有构造函数、析构函数和无需用户干预的默认构造函数。

因此，聚合初始化也被看作是一种```裸机初始化```，和普通构造函数或自定义初始化函数有所不同。

### auto

### decltype

### 追踪返回类型

### 智能指针

### 变长模版

### 原子类型与原子操作

### 默认函数控制

### lambda函数

### 对齐支持
